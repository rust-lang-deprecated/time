use std::error::Error;
use std::string::String;
use std::string::ToString;

use super::*;
use sys;
use duration::*;


/// An opaque structure representing a moment in time.
///
/// The only operation that can be performed on a `PreciseTime` is the
/// calculation of the `Duration` of time that lies between them.
///
/// # Examples
///
/// Repeatedly call a function for 1 second:
///
/// ```rust
/// use time::{Duration, PreciseTime};
/// # fn do_some_work() {}
///
/// let start = PreciseTime::now();
///
/// while start.to(PreciseTime::now()) < Duration::seconds(1) {
///     do_some_work();
/// }
/// ```
#[derive(Copy, Clone)]
pub struct PreciseTime(u64);

impl PreciseTime {
    /// Returns a `PreciseTime` representing the current moment in time.
    pub fn now() -> PreciseTime {
        PreciseTime(precise_time_ns())
    }

    /// Returns a `Duration` representing the span of time from the value of
    /// `self` to the value of `later`.
    ///
    /// # Notes
    ///
    /// If `later` represents a time before `self`, the result of this method
    /// is unspecified.
    ///
    /// If `later` represents a time more than 293 years after `self`, the
    /// result of this method is unspecified.
    #[inline]
    pub fn to(&self, later: PreciseTime) -> Duration {
        // NB: even if later is less than self due to overflow, this will work
        // since the subtraction will underflow properly as well.
        //
        // We could deal with the overflow when casting to an i64, but all that
        // gets us is the ability to handle intervals of up to 584 years, which
        // seems not very useful :)
        Duration::nanoseconds((later.0 - self.0) as i64)
    }
}

/// A structure representing a moment in time.
///
/// `SteadyTime`s are generated by a "steady" clock, that is, a clock which
/// never experiences discontinuous jumps and for which time always flows at
/// the same rate.
///
/// # Examples
///
/// Repeatedly call a function for 1 second:
///
/// ```rust
/// # use time::{Duration, SteadyTime};
/// # fn do_some_work() {}
/// let start = SteadyTime::now();
///
/// while SteadyTime::now() - start < Duration::seconds(1) {
///     do_some_work();
/// }
/// ```
#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Debug)]
pub struct SteadyTime(sys::SteadyTime);

impl SteadyTime {
    /// Returns a `SteadyTime` representing the current moment in time.
    pub fn now() -> SteadyTime {
        SteadyTime(sys::SteadyTime::now())
    }
}

impl fmt::Display for SteadyTime {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        // TODO: needs a display customization
        fmt::Debug::fmt(self, fmt)
    }
}

impl Sub for SteadyTime {
    type Output = Duration;

    fn sub(self, other: SteadyTime) -> Duration {
        self.0 - other.0
    }
}

impl Sub<Duration> for SteadyTime {
    type Output = SteadyTime;

    fn sub(self, other: Duration) -> SteadyTime {
        SteadyTime(self.0 - other)
    }
}

impl Add<Duration> for SteadyTime {
    type Output = SteadyTime;

    fn add(self, other: Duration) -> SteadyTime {
        SteadyTime(self.0 + other)
    }
}

/// Returns the current time in UTC
pub fn now_utc() -> Tm {
    at_utc(get_time())
}

/// Returns the current time in the local timezone
pub fn now() -> Tm {
    at(get_time())
}

/// Formats the time according to the format string.
pub fn strftime(format: &str, tm: &Tm) -> Result<String, ParseError> {
    tm.strftime(format).map(|fmt| fmt.to_string())
}

/**
 * Returns the current time as a `timespec` containing the seconds and
 * nanoseconds since 1970-01-01T00:00:00Z.
 */
pub fn get_time() -> Timespec {
    let (sec, nsec) = sys::get_time();
    Timespec::new(sec, nsec)
}


/**
 * Returns the current value of a high-resolution performance counter
 * in nanoseconds since an unspecified epoch.
 */
pub fn precise_time_ns() -> u64 {
    sys::get_precise_ns()
}


/**
 * Returns the current value of a high-resolution performance counter
 * in seconds since an unspecified epoch.
 */
pub fn precise_time_s() -> f64 {
    return (precise_time_ns() as f64) / 1000000000.;
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            InvalidFormatSpecifier(ch) => {
                write!(f, "{}: %{}", self.description(), ch)
            }
            UnexpectedCharacter(a, b) => {
                write!(f, "expected: `{}`, found: `{}`", a, b)
            }
            _ => write!(f, "{}", self.description())
        }
    }
}

impl Error for ParseError {
    fn description(&self) -> &str {
        match *self {
            InvalidSecond => "Invalid second.",
            InvalidMinute => "Invalid minute.",
            InvalidHour => "Invalid hour.",
            InvalidDay => "Invalid day.",
            InvalidMonth => "Invalid month.",
            InvalidYear => "Invalid year.",
            InvalidDayOfWeek => "Invalid day of the week.",
            InvalidDayOfMonth => "Invalid day of the month.",
            InvalidDayOfYear => "Invalid day of the year.",
            InvalidZoneOffset => "Invalid zone offset.",
            InvalidTime => "Invalid time.",
            InvalidSecondsSinceEpoch => "Invalid seconds since epoch.",
            MissingFormatConverter => "missing format converter after `%`",
            InvalidFormatSpecifier(..) => "invalid format specifier",
            UnexpectedCharacter(..) => "Unexpected character.",
        }
    }
}


#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_precise_time() {
        let s0 = precise_time_s();
        debug!("s0={} sec", s0);
        assert!(s0 > 0.);

        let ns0 = precise_time_ns();
        let ns1 = precise_time_ns();
        debug!("ns0={} ns", ns0);
        debug!("ns1={} ns", ns1);
        assert!(ns1 >= ns0);

        let ns2 = precise_time_ns();
        debug!("ns2={} ns", ns2);
        assert!(ns2 >= ns1);
    }

    #[test]
    fn test_precise_time_to() {

        let t0 = PreciseTime(1000);
        let t1 = PreciseTime(1023);
        assert_eq!(Duration::nanoseconds(23), t0.to(t1));
    }

    #[test]
    fn test_steadytime_sub() {
        let a = SteadyTime::now();
        let b = a + Duration::seconds(1);
        assert_eq!(b - a, Duration::seconds(1));
        assert_eq!(a - b, Duration::seconds(-1));
    }
}
